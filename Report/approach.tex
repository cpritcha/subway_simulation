\section{Approach}
Plenty of literature exists on modeling both surface rail networks, which typically cover longer distances, and subway or light-rail systems, which typically operate with a higher train frequency. Where simulations of surface rail networks might focus on maintaining arrival and departure schedules, subway and metro systems are more interested in keeping the trains moving and avoiding deadlock.  Deadlock is a state where no train can advance.  For example, consider a scenario where a train is broken down for an extended period of time.  As time advances, trains continue to arrive behind the disabled train, but are unable to pass.  Eventually all trains are stuck behind the disabled train.  Careful placement and management of track switches can be used to allow trains to overtake and pass a disabled train. These management schemes require modeling and simulation to evaluate their effectiveness.  According to Ref.~\citen{ttcservice}, Toronto subway trains run every two to seven minutes. Even small delays of just a couple minutes can result in relatively significant delays.

The approach considered here consists of five atomic components coupled together: stations, track sections, trains, passengers and a scheduler. A hierarchy and some simple relationships between the components are shown in Fig.~\ref{fig:hierarchy}.  Stations and track sections are modeled similarly, with the exception that passengers can be unloaded and loaded at stations. Two tracks, one for each direction, join stations together. Each train carries up to a specified maximum number of passengers. The time to load and unload passengers is linearly dependent on the number of passengers involved in the operations. Passengers originate and terminate at stations.  Trains may also suffer from failures, which cause delays in service.  The role of the scheduler is to control the movement of the trains and ensure no collisions or deadlocks occur.  The models for these components are described in more detail in the following sections.
%
\begin{figure}[htb]
	\centering
	\includegraphics[width=6.5in]{hierarchy.png}
	\caption{Component Hierarchy}
	\label{fig:hierarchy}
\end{figure}
%
\subsection{Station Model}
The station serves as the creation and destruction point for passengers.  The station is also the only location where trains may load or unload passengers. The station is responsible for maintaining a pool of waiting passengers.  If a train does not have enough capacity to board all waiting passengers, then those passengers persist at the station and wait for the next train.  Also, if at any point a train must unload all of its passengers, in the event of an extended breakdown for example, any passengers not at their final destination will be added to the waiting passengers queue. In generating passengers, the station implements multiple options for generating destinations for each passenger.  In each of the destination options, the destinations are chosen from a predefined set of destinations that does not include the origin station.  One method for generating the destination is to loop through the possible destinations repeatedly, in order.  Another method is to specify a single destination for all passengers.  The third option is to generate a random destination.

The inputs to the station are a set of passengers to unload from the arriving train and the available capacity of the arriving train.  Both of these values are contained within the same message on the input port.  This accomplished with a new derived \texttt{Entity} type.  The output is a set of passengers to load onto the train. For its states, the station may be simply waiting, unloading passengers from a train, or providing passengers to a train.  The station model must also have a state variable that holds the current waiting passenger collection. 

After unloading passengers from a train, the station immediately updates its waiting passenger list.  The amount of passengers generated is specified by a rate.  The rate is given in units of passengers per minute.  When generating passengers, the total amount of passengers generated at that instant is the specified rate multiplied by a time.  The time used is the difference between the current internal clock value and the previous clock value at which passengers were created.  The internal clock and previous passenger generation time are both stored in state variables.  Once the created passengers are added to the waiting passengers list, the station takes up to as many passengers as the current train capacity from the front of the list adds them to a list of passengers to load on the train.  This list is then sent along with the unique station identifier as output.  The unique station identifier is used by the scheduler/coordinator to route the passengers to the correct train.  The scheduler is discussed in more detail in a later section. 
\begin{align*}
DEVS_{\textrm{Station}} &= \left<X,Y,S,\delta_{ext},\delta_{int},\lambda,ta\right> \\
P &= Passenger\ Collection, |P|\in\mathbb{N}_0^+ \\
P_w &= \text{Waiting passenger list} \\
P_l &= \text{List of passengers to load} \\
C &= \text{Passenger capacity of current train} \\
ID &= \text{Unique station identifier} \\
X &= \lbrace(\text{``Unload Passengers''},\lbrace P, C|C\in\mathbb{N}_0\rbrace)\rbrace \\
Y &= \lbrace(\text{``Load Passengers''},\lbrace P_l|\ |P_l|\leq C, P_l\subseteq P_w\rbrace\cup\emptyset)\rbrace \\
S_{clock} &= \mathbb{R}_0^+ \\ 
S_{timeOfLastPassengerCreation} &= \mathbb{R}_0^+ \\
S_{action} &= \lbrace\text{``passive'', ``Unload Passengers'',} \\
	& \text{``Load Passengers''}\rbrace \\
S_{waitingPassengers} &= \lbrace P_w, |P_w|\in\mathbb{N}_0^+\rbrace \\
S_{loadingPassengers} &= \lbrace P_l, |P_l|\leq C\rbrace \\ 
S &= S_{action}\times S_{clock}\times \\
 & S_{timeOfLastPassengerCreation}\times S_{waitingPassengers} \\
 & S_{loadingPassengers}\times \mathbb{R}_0^+ \\
\delta_{ext}(\text{``passive''},e,(\text{``Unload Passsengers''},\lbrace u|u\in\mathbb{N}_0\rbrace)) &= (\text{``Unload Passengers''},0,\lbrace P, C\rbrace) \\
\delta_{int}(\text{``passive''}) &= \text{``passive''} \\
\delta_{int}(\text{``Unload Passengers''},\sigma) &= (\text{``Load Passengers''},0,\lbrace ID, P\rbrace)\rbrace\ \\
\delta_{int}(\text{``Load Passengers''},\sigma) &= (\text{``passive''}) \\
\delta_{con}(s,ta(s),x) &= \delta_{ext}(\delta_{int}(s),0,x) \\
\lambda(\text{``Load Passengers''}) &= \lbrace ID,\lbrace P, |P|\leq C\rbrace\cup\emptyset\rbrace \\
ta(s) &= 0 \\
ta(``passive'') &= \infty \\
\end{align*}
%
\subsection{Track Section Model}

The track section model is needed to control access to track sections. A train
is permitted to enter a section if there is remaining capacity in the section.
When a train leaves a section the section's remaining capacity is increased by
one. The track section model can be represented by the DEVS with ports model 
below.

\newcommand{\InEnterReq}[0]{(\text{``Enter Request''}, ())}
\newcommand{\InExitReq}[0]{(\text{``Exit Request''}, ())}

\newcommand{\OutEnterRes}[1]{(\text{``Enter Response''}, #1)}

\begin{align*}
DEVS_{\textrm{Track}} &= \left<X,Y,S,\delta_{ext},\delta_{int},\lambda,ta\right> \\
    A &= \text{Number of trains allowed on section} \\
    X &= \{\InEnterReq, \\
        & \InExitReq
    \} \\
    Y &= \{\OutEnterRes{\{\text{May enter}, \text{May not enter}\}}\} \\
    S &= \{ a | a \in \mathbb{N}_0, a \leq A \} \\
    ta(S) &= \infty \\
    \delta_{ext}(a, e, \InEnterReq) &= 
        \begin{cases}
            a - 1 & \text{if\;} a > 0 \\
            a & \text{otherwise} \\
        \end{cases} \\
    \delta_{ext}(a, e, \InExitReq) &= 
        \begin{cases}
            a + 1 & \text{if\;} a < A \\
            a & \text{otherwise} \\
        \end{cases} \\
    \lambda(a) &= 
        \begin{cases}
            \text{May enter} & \text{if\;} a > 0 \\
            \text{May not enter} & \text{otherwise} \\
        \end{cases}
\end{align*}

\subsection{Train Model}

Trains travel station to station to unload and load passengers. Sometimes they
break down. They also follow a movement protocol and a loading and unloading
protocol. In the loading and unloading protocol, a train arrives at a station,
unloads some of its passengers, waits for a capacity request, responds with a
remaining capacity and awaits for the station to load the train. In the movement
protocol, the train asks the scheduler if it can be move forward and scheduler
replies with an accepted or rejected. Trains rejected from proceeding to the
next section still proceed as far as they can within their section. This
behavior is represented by the DEVS with ports model below. Any missing
transitions are assumed to return the input state. 

The model makes some simplifying assumptions. It assumes that each track section
includes stations and the track up to the next station. This assumption could be
relaxed by having the train keep track of whether or not the train is at a
station. A 50\% disembark rate is also assumed for unloading at each station. A
more detailed model would include each passengers destination station so that
forced breakdowns event would force passengers to exit and those that did not
reach their desired destination would board the next train (this model assumes
disembarkers never reboard). It also assumes that breakdown repair times and in
need of repair times are constant.

\newcommand{\InBreakDown}[0]{(\text{``Breakdown''}, ())}
\newcommand{\InCapReq}[0]{(\text{``Capacity Request''}, ())}
\newcommand{\InMoveRes}[1]{(\text{``Move Response''}, #1)}
\newcommand{\InLoadPassengers}[1]{(\text{``Load Passengers''}, #1)}

\newcommand{\OutRemainingCapacity}[1]{(\text{``Remaining Capacity''}, #1)}
\newcommand{\OutUnloadPassengers}[1]{(\text{``Unload Passengers''}, #1)}
\newcommand{\OutMoveReq}[1]{(\text{``Move Request''}, #1)}
\newcommand{\phase}[0]{\text{phase}}

\newcommand{\Mod}[2]{\mathrm{mod} (#1, #2)}

\begin{align*}
DEVS_{\textrm{Train}} &= \left<X,Y,S,\delta_{ext},\delta_{int},\lambda,ta\right> \\
    T &= \text{\# of trains} \\
    N &= \# \text{\;of train stations} \\
    C &= \text{Passenger capacity of train} \\
    m &= \text{Travel time from end of track} \\
        & \text{section to next section} \\
    X &= \{
      \InBreakDown, \\
      &  \InCapReq, \\
      &  \InLoadPassengers{\{ p | p \in \mathbb{N}_0, p \leq C \}} \\
      &  \InMoveRes{\{ \text{Accepted}, \text{Rejected} \}}
    \} \\
    Y &= \{
      \OutRemainingCapacity{\{ c | c \in \mathbb{N}_0 \}}, \\
      &  \OutUnloadPassengers{\{ u | u \in \mathbb{N}_0 \}}, \\
      &  \OutMoveReq{\\ 
        & \{ (i, t) | i \in \mathbb{N}_0, i < N, t \in \mathbb{N}_0, t < T \}}
    \} \\
    S_{action} &= \{
      \text{moving}, \text{needs repairs}, \text{in repair}, \\
      &  \text{loading}, \text{unloading}, \text{waiting for load}, \\
      &  \text{waiting for cap req} 
    \} \\
    S_{\text{position}} &= \{ i | i \in \mathbb{N}_0, i < N
    \} \\
    S_{passengers} &= \{ p | p \in \mathbb{N}_0, p \leq C \} \\
    S &= S_{action} \times S_{position} \times S_{passengers} \times \sigma \\
    ta(a, i, p, \sigma) &= \sigma \\
    %
    \delta_{ext}((\text{moving}, i, p, \sigma), e, \InBreakDown) &= 
        (\text{needs repair}, i, p, \\
        & \text{time till repairs start}) \\
    \delta_{ext}((\text{moving}, i, p, \sigma), e, \InMoveRes{\text{Accepted}})
        &= (\text{unloading}, \Mod{i+1}{N}, \ceil*{p/2}, \\
        & \text{loading time}) \\
    \delta_{ext}((\text{moving}, i, p, \sigma), e, \InMoveRes{\text{Rejected}})
        &= (\text{moving}, i, p, \max(m, \sigma - e)) \\
    \delta_{ext}((\text{waiting for cap req}, i, p, \sigma), e, \InCapReq) &=
        (\text{waiting for load}, i, p, \infty) \\
    \delta_{ext}((\text{waiting for load}, i, p, \sigma), e, \InLoadPassengers{p_{load}}) &=
        (\text{loading}, i, p + p_{load}, \text{loading time}) \\
    %
    \delta_{int}(\text{unloading}, i, p, \sigma) &= 
        (\text{waiting for cap req}, i, p, \infty) \\
    \delta_{int}(\text{loading}, i, p, \sigma) &= (\text{moving}, i, p,
        \text{time to next station}) \\
    \delta_{int}(\text{needs repair}, i, p, \sigma) &= 
        (\text{in repair}, i, p, \text{repair time}) \\
    \delta_{int}(\text{in repair}, i, p, \sigma) &= 
        (\text{moving}, i, p, \text{time to next station}) \\
    %
    \lambda(\text{moving}, i, p, \sigma) &= \OutMoveReq{(i, t)} \\ 
        & \text{\;where\;} t \text{\;is the constant train ID} \\
    \lambda(\text{unloading}, i, p, \sigma) &= \OutUnloadPassengers{\floor*{p/2}} \\
    \lambda(\text{waiting for cap req}, i, p, \sigma) &= \OutRemainingCapacity{C - p}
\end{align*}


\subsection{Scheduler Model}
A preliminary formal definition of the DEVS scheduler model is provided below. When a train is ready to resume moving it sends a move request in the form of its ID as in input to the scheduler.  Internally, the scheduler verifies whether or not it is safe to move.  It also identifies any trains currently waiting on the inquiring train.  It takes this collection of trains and outputs move commands to each.  In the case where no trains are able to move, the output is an empty set. The model remains in a perpetual state of waiting until it receives a move request from one of the trains.  It processes this request accordingly, responds, and then reverts back to a waiting state. The state consists of the two phases, waiting or moving trains, and state variables that store the input ID of the requesting train and its position.
\begin{align*} DEVS_{\textrm{Scheduler}} &= \left<X,Y,S,\delta_{ext},\delta_{int},\lambda,ta\right> \\
C &= \text{Remaining train capacity} \\
P &= \text{A list of passengers}\cup\emptyset \\
T &= \text{A group of trains} \\
L &= \text{A loop of track and station instances} \\
X &= \lbrace (\text{``Unload Passengers''},(Train\ ID, P, C)), \\
 & (\text{``Request Move to Station''},(Train\ ID)), \\
 & (\text{``Request Move to Track''},(Train\ ID)), \\
 & (\text{``Passengers to Load''},(Station\ ID, P)), \\
%& (\text{``Breakdown''},(Train\ ID,\mathbb{R}_0^+)), \\
 & (\text{``Acquire''},(x|x\in\lbrace True,False\rbrace)), \\
 & (\text{``Release''},(x|x\in\lbrace True,False\rbrace))\rbrace \\
Y &= \lbrace(\text{``Move to Track''},(Train\ ID,\mathbb{R}_0^+)), \\
 & (\text{``Move to Station''},(Train\ ID, Station\ ID)), \\
 & (\text{``Board Passengers''},(Train\ ID, P)), \\
 & (\text{``Unload Passengers''},(Station\ ID, P)), \\
 & (\text{``Acquire''},(Train\ ID)), \\
 & (\text{``Release''},(Train\ ID)), \\
 & (\text{``N Passengers Delivered''},(\mathbb{N}_0^+)) \\
S_{action} &= \lbrace \text{``passive'',``processing''}\rbrace \\
S_{trainPosition} &= \lbrace t_k|t_k\in\mathbb{N}_0^+, 0\leq k<|T|\rbrace \\
S_{segmentPopulated} &= \lbrace x_k|x_k\in\lbrace True,False\rbrace, 0\leq k<|L|\rbrace \\
S &= S_{action}\times S_{trainPosition}\times \\
 & S_{segmentPopulated}\times\mathbb{R}_0^+ \\
\delta_{ext}(\text{``passive''},e,(\text{``Unload Passengers''},&(Train\ ID,P,C))) = \\ &(\text{``processing''},0,(Train\ ID,P,C)) \\
\delta_{ext}(\text{``passive''},e,(\text{``Request Move to Station''},&(Train\ ID))) = \\
&(\text{``processing''},0,(Train\ ID)) \\
\delta_{ext}(\text{``passive''},e,(\text{``Request Move to Track''},&(Train\ ID))) = \\
&(\text{``processing''},0,(Train\ ID)) \\
\delta_{ext}(\text{``passive''},e,(\text{``Passengers to Load''},&(Station\ ID,P))) = \\
&(\text{``processing''},0,(Station\ ID)) \\
\delta_{ext}(\text{``passive''},e,(\text{``Acquire''},&(boolean))) = \\
&(\text{``processing''},0,(boolean)) \\
\delta_{ext}(\text{``passive''},e,(\text{``Release''},&(boolean))) = \\
&(\text{``processing''},0,(boolean)) \\
\delta_{int}(\text{``processing''},\sigma) &= \text{``passive''} \\
\delta_{int}(\text{``passive''}) &= \text{``passive''} \\
\lambda(\text{``Move to Track''},\sigma,(Train\ ID,\mathbb{R}_0^+)) &= (\text{``Move to Track''},T\times\mathbb{R}_0^+) \\
\lambda(\text{``Move to Station''},\sigma,(Train\ ID,Station\ ID)) &= (\text{``Move to Station''},T\times S | S\subset L) \\
\lambda(\text{``Board Passengers''},\sigma,(Train\ ID,P)) &= (\text{``Board Passengers''},T\times P) \\
\lambda(\text{``Unload Passengers''},\sigma,(Station\ ID,P)) &= (\text{``Unload Passengers''}, S\times P | S\subset L) \\
\lambda(\text{``Acquire''},\sigma,(Train\ ID)) &= (\text{``Acquire''},t\in T) \\
\lambda(\text{``Release''},\sigma,(Train\ ID)) &= (\text{``Release''},t\in T) \\
\lambda(\text{``N Passengers Delivered''},\sigma,(\mathbb{N}_0^+)) &= (\text{``N Passengers Delivered''},n\in \mathbb{N}_0^+) \\
ta(s) &= 0 \\ 
ta(\text{``passive''}) &= \infty \\
\end{align*}

\subsection{Planned Experiments}
The primary experiments will focus on disruptions in service due to train maintenance issues.  Given a train breakdown that causes a blockage on one of the tracks, we shall examine the effectiveness of a meet and pass routine.  Effectiveness shall be judged by the ability of the trains to pass by switching tracks without causing a deadlock, without causing significant delays in trains traveling in the opposite direction due to the track switching, and by monitoring passenger counts at the stations.  Monitoring the passenger counts is to evaluate that the service disruption does not cause a severe sustained surge in passengers waiting to board.  Another experiment will look at the effect of passenger surges at a given station, during rush hour for example, and the subway network's ability to maintain train movement given the increased loading and unloading times due to the surge. 

These experiments will also involve varying the number of trains in service, with the goal of finding the optimum number of trains particular to the subway circuit modeled.  An increase in the number of trains may nominally be able to carry a larger number of passengers, assuming the number of trains does not exceed the number of stations.  However, if a disruption occurs and a train is disabled, this can quickly lead to deadlock as there is no extra bandwidth in the rail system to allow the trains to switch and get around the disabled train because all stations are occupied at any given time.  Conversely, if there are too few trains operating it runs the risk of not having enough total capacity to carry the influx of passengers, even though it may be easier to overcome service disruptions.

\subsection{Expected Outcomes}

The subway simulation in this paper is designed to focus on two outcome variables: passenger wait times at stations and train delays. The expected outcome from this simulation is that increases in passing areas decreases train delays and a increased number of trains to service a subway line results in lower passenger wait times at stations.